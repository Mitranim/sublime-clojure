%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html

name: Clj
file_extensions:
  - clj
  - cljc
  - cljs
  - edn
scope: source.clojure

variables:
  non_symbol_chars: \s,;\(\)\[\]{}\"`~@\^\\
  non_symbol_start_chars: '{{non_symbol_chars}}\d#'':'
  non_number_chars: '{{non_symbol_chars}}#'''
  non_char_chars: '{{non_symbol_chars}}#'''
  symbol: (?:/|[^{{non_symbol_start_chars}}][^{{non_symbol_chars}}]*)

  # slightly too permissive on "/", too complex
  keyword: |
    (?x) # trim regex
    ::?(?:
      [^:{{non_symbol_chars}}]
      |
      [^:{{non_symbol_chars}}]
      (?:[^{{non_symbol_chars}}](?!::|/\d))*
      [^:{{non_symbol_chars}}]
    )
    (?=[{{non_symbol_chars}}])

  constant: (?:nil|true|false)(?=[{{non_symbol_chars}}])
  evil_octal: '[-+]?0\d+N?(?=[{{non_symbol_chars}}])'

  # similar to regexes in Clojure reader, rolled into one
  # doesn't accept octals and decimals ending with dot
  number: |
    (?x) # trim regex
    [-+]?
    (?:
      \d+N?                             # int
      |0[Xx][0-9A-Fa-f]+N?              # hex int
      |[1-9]\d*[Rr][0-9A-z]+            # n-radix int
      |\d+/\d+                          # ratio
      |\d+(?:\.\d+)?(?:[Ee][-+]?\d+)?M? # decimal with scientific notation
    )
    (?=[{{non_number_chars}}])

contexts:
  main:
    - include: match-expr

  match-expr:
    - include: match-noise
    - match: '[)\]}]'
      scope: invalid.illegal.clojure
    - match: \(
      scope: punctuation.section.parens.begin.clojure
      push: pop-list-head
    - match: \[
      scope: punctuation.section.brackets.begin.clojure
      push:
        - match: \]
          scope: punctuation.section.brackets.end.clojure
          pop: true
        - include: match-expr
    - match: '#?{'
      scope: punctuation.section.brackets.begin.clojure
      push:
        - match: '}'
          scope: punctuation.section.brackets.end.clojure
          pop: true
        - include: match-expr
    - match: '#'
      scope: constant.other.symbol.reader-macro.clojure
      push: pop-dispatch-expr
    - match: '''|`|~@|~'
      scope: constant.other.symbol.reader-macro.clojure
      push: pop-expr
    - match: '@'
      scope: variable.function.deref.clojure
      push: pop-expr
    - match: '"'
      scope: punctuation.definition.string.begin.clojure
      push: pop-string-tail
    - match: \\\S[^{{non_char_chars}}]*
      scope: constant.character.clojure
    - match: '{{constant}}'
      scope: constant.language.clojure
    - match: '{{keyword}}'
      scope: constant.language.keyword.clojure
    - match: '{{evil_octal}}'
      scope: invalid.illegal.clojure
    - match: '{{number}}'
      scope: constant.numeric.clojure
    - match: '[^{{non_symbol_chars}}]+'

  pop-expr:
    - include: match-noise
    - match: '[)\]}]'
      scope: invalid.illegal.clojure
      pop: true
    - match: \(
      scope: punctuation.section.parens.begin.clojure
      set: pop-list-head
    - match: \[
      scope: punctuation.section.brackets.begin.clojure
      set:
        - match: \]
          scope: punctuation.section.brackets.end.clojure
          pop: true
        - include: match-expr
    - match: '#?{'
      scope: punctuation.section.brackets.begin.clojure
      set:
        - match: '}'
          scope: punctuation.section.brackets.end.clojure
          pop: true
        - include: match-expr
    - match: '#'
      scope: constant.other.symbol.reader-macro.clojure
      set: pop-dispatch-expr
    - match: '''|`|~@|~'
      scope: constant.other.symbol.reader-macro.clojure
      set: pop-expr
    - match: '@'
      scope: variable.function.deref.clojure
      set: pop-expr
    - match: '"'
      scope: punctuation.definition.string.begin.clojure
      set: pop-string-tail
    - match: '\\\S[^{{non_char_chars}}]*'
      scope: constant.character.clojure
      pop: true
    - match: '{{constant}}'
      scope: constant.language.clojure
      pop: true
    - match: '{{keyword}}'
      scope: constant.language.keyword.clojure
      pop: true
    - match: '{{evil_octal}}'
      scope: invalid.illegal.clojure
      pop: true
    - match: '{{number}}'
      scope: constant.numeric.clojure
      pop: true
    - match: '[^{{non_symbol_chars}}]+'
      pop: true

  match-noise:
    - match: (;+).*
      scope: comment.line.clojure
      captures:
        1: punctuation.definition.comment
    - match: ','
      scope: comment.punctuation.comma.clojure
    - match: \^
      scope: constant.other.symbol.reader-macro.clojure
      push: pop-expr

  pop-dispatch-expr:
    - match: \s*
    - match: '{{constant}}'
      scope: constant.language.clojure
      pop: true
    - match: '{{symbol}}'
      scope: constant.other.symbol.reader-macro.clojure
      pop: true
    - match: (?=\S)
      set: pop-expr

  pop-string-tail:
    - meta_scope: string.clojure
    - match: \\.
      scope: constant.character.escape.clojure
    - match: '"'
      scope: punctuation.definition.string.end.clojure
      pop: true

  pop-list-head:
    - include: match-noise
    - match: defprotocol[^{{non_symbol_chars}}]*
      scope: storage.type.def.clojure
      set: pop-declare-protocol-list-tail
    - match: definterface[^{{non_symbol_chars}}]*
      scope: storage.type.def.clojure
      set: pop-declare-interface-list-tail
    - match: (?:deftype|defrecord)[^{{non_symbol_chars}}]*
      scope: storage.type.def.clojure
      set: pop-declare-type-list-tail
    - match: defmethod[^{{non_symbol_chars}}]*
      scope: storage.type.def.clojure
      set: pop-list-tail
    - match: def[^{{non_symbol_chars}}]*
      scope: storage.type.def.clojure
      set: pop-declare-def-list-tail
    - match: fn\*?(?=[{{non_symbol_chars}}])
      scope: storage.type.fn.clojure
      set: pop-fn-list-tail
    - match: (?=\S)
      set: pop-invoke-list-tail

  pop-list-tail:
    - match: \)
      scope: punctuation.section.parens.end.clojure
      pop: true
    - include: match-expr

  pop-declare-protocol-list-tail:
    - include: match-constant-set-normal-list-tail
    - match: '{{symbol}}'
      scope: entity.name.type.clojure
      set: pop-protocol-list-tail
    - include: set-normal-list-tail

  pop-declare-interface-list-tail:
    - include: match-constant-set-normal-list-tail
    - match: '{{symbol}}'
      scope: entity.name.type.clojure
      set: pop-interface-list-tail
    - include: set-normal-list-tail

  pop-declare-type-list-tail:
    - include: match-constant-set-normal-list-tail
    - match: '{{symbol}}'
      scope: entity.name.type.clojure
      set: pop-type-list-tail
    - include: set-normal-list-tail

  pop-declare-def-list-tail:
    - include: match-constant-set-normal-list-tail
    - match: '{{symbol}}'
      scope: entity.name.function.clojure
      set: pop-list-tail
    - include: set-normal-list-tail

  pop-protocol-list-tail:
    - match: \)
      scope: punctuation.section.parens.end.clojure
      pop: true
    - match: \(
      scope: punctuation.section.parens.begin.clojure
      push: pop-declare-def-list-tail
    - include: match-expr

  pop-interface-list-tail:
    - match: \)
      scope: punctuation.section.parens.end.clojure
      pop: true
    - match: \(
      scope: punctuation.section.parens.begin.clojure
      push: pop-fn-list-tail
    - include: match-expr

  pop-type-list-tail:
    - match: \)
      scope: punctuation.section.parens.end.clojure
      pop: true
    - match: \(
      scope: punctuation.section.parens.begin.clojure
      push: pop-fn-list-tail
    - include: match-expr

  pop-fn-list-tail:
    - include: match-constant-set-normal-list-tail
    - match: '{{symbol}}'
      scope: entity.name.fn.clojure
      set: pop-list-tail
    - include: set-normal-list-tail

  pop-invoke-list-tail:
    - include: match-constant-set-normal-list-tail
    - match: '{{symbol}}'
      scope: variable.function.clojure
      set: pop-list-tail
    - include: set-normal-list-tail

  match-constant-set-normal-list-tail:
    - include: match-noise
    - match: '{{constant}}'
      scope: constant.language.clojure
      set: pop-list-tail

  set-normal-list-tail:
    - match: (?=\S)
      set: pop-list-tail
