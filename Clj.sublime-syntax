%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html

name: Clj
file_extensions:
  - clj
  - cljc
  - cljs
  - edn
scope: source.clojure

variables:
  non_symbol_chars: '\s,;\(\)\[\]{}"`~@\^\\'
  non_symbol_start_chars: '{{non_symbol_chars}}\d#'':'
  symbol: '(?:[^{{non_symbol_start_chars}}][^{{non_symbol_chars}}]*)'
  constant: '(?:nil|true|false)(?=[{{non_symbol_chars}}])'
  evil_octal: '[-+]?0\d+N?(?=[{{non_symbol_chars}}])'
  # similar to regexes in Clojure reader, rolled into one
  # doesn't accept octals and decimals ending with dot
  number: |
    (?x)    # ignore whitespace and comments in regex
    [-+]?
    (?:
      \d+N?|                           # int
      0[Xx][0-9A-Fa-f]+N?|             # hex int
      [2-9]\d*[Rr][0-9A-z]+|           # n-radix int
      \d+/\d+|                         # ratio
      \d+(?:\.\d+)?(?:[Ee][-+]?\d+)?M? # decimal with scientific notation
    )
    (?=[{{non_symbol_chars}}])

contexts:
  main:
    - include: match_expr
  match_expr:
    - include: match_noise
    - match: '[)\]}]'
      scope: invalid.illegal.clojure
    - match: '\('
      push: pop_list_head
    - match: '\['
      push:
        - match: '\]'
          pop: true
        - include: match_expr
    - match: '#?{'
      push:
        - match: '}'
          pop: true
        - include: match_expr
    - match: '''|`|~@|~|#{{symbol}}?'
      scope: constant.other.symbol.reader_macro.clojure
      push: pop_expr
    - match: '@'
      scope: keyword.deref.clojure
      push: pop_expr
    - match: '"'
      scope: punctuation.definition.string.clojure
      push: pop_string_tail
    - match: '\\[^{{non_symbol_chars}}]+'
      scope: constant.character.clojure
    - match: '{{constant}}'
      scope: constant.clojure
    - match: '::?{{symbol}}'
      scope: constant.keyword.clojure
    - match: '{{evil_octal}}'
      scope: invalid.illegal.clojure
    - match: '{{number}}'
      scope: constant.numeric.clojure
    - match: '[^{{non_symbol_chars}}]+'
  pop_expr:
    - include: match_noise
    - match: '[)\]}]'
      scope: invalid.illegal.clojure
      pop: true
    - match: '\('
      set: pop_list_head
    - match: '\['
      set:
        - match: '\]'
          pop: true
        - include: match_expr
    - match: '#?{'
      set:
        - match: '}'
          pop: true
        - include: match_expr
    - match: '''|`|~@|~|#{{symbol}}?'
      scope: constant.other.symbol.reader_macro.clojure
      set: pop_expr
    - match: '@'
      scope: keyword.deref.clojure
      set: pop_expr
    - match: '"'
      scope: punctuation.definition.string.clojure
      set: pop_string_tail
    - match: '\\[^{{non_symbol_chars}}]+'
      scope: constant.character.clojure
      pop: true
    - match: '{{constant}}'
      scope: constant.clojure
      pop: true
    - match: '::?{{symbol}}'
      scope: constant.keyword.clojure
      pop: true
    - match: '{{evil_octal}}'
      scope: invalid.illegal.clojure
      pop: true
    - match: '{{number}}'
      scope: constant.numeric.clojure
      pop: true
    - match: '[^{{non_symbol_chars}}]+'
      pop: true
  match_noise:
    - match: ';.*'
      scope: comment.clojure
    - match: ','
      scope: comment.punctuation.clojure
    - match: '\^'
      scope: constant.other.symbol.reader_macro.metadata.clojure
      push: pop_expr
  pop_string_tail:
    - meta_scope: string.clojure
    - match: '\\.'
      scope: constant.character.escape.clojure
    - match: '"'
      scope: punctuation.definition.string.clojure
      pop: true
  pop_list_head:
    - include: match_noise
    - match: '(?:defprotocol)[^{{non_symbol_chars}}]*'
      scope: storage.type.def.clojure
      set: pop_declare_protocol_list_tail
    - match: '(?:definterface|deftype|defrecord)[^{{non_symbol_chars}}]*'
      scope: storage.type.def.clojure
      set: pop_declare_type_list_tail
    - match: 'defmethod[^{{non_symbol_chars}}]*'
      scope: storage.type.def.clojure
      set: pop_list_tail
    - match: 'def[^{{non_symbol_chars}}]*'
      scope: storage.type.def.clojure
      set: pop_declare_def_list_tail
    - match: 'fn\*?(?=[{{non_symbol_chars}}])'
      scope: storage.type.fn.clojure
      set: pop_color_name_list_tail
    - match: '(?=\S)'
      set: pop_color_name_list_tail
  pop_list_tail:
    - match: '\)'
      pop: true
    - include: match_expr
  pop_declare_protocol_list_tail:
    - include: match_noise
    - match: '{{constant}}'
      scope: constant.clojure
      set: pop_protocol_list_tail
    - match: '{{symbol}}'
      scope: entity.name.type.clojure
      set: pop_protocol_list_tail
    - match: '(?=\S)'
      set: pop_protocol_list_tail
  pop_declare_type_list_tail:
    - include: match_noise
    - match: '{{constant}}'
      scope: constant.clojure
      set: pop_list_tail
    - match: '{{symbol}}'
      scope: entity.name.type.clojure
      set: pop_list_tail
    - match: '(?=\S)'
      set: pop_list_tail
  pop_declare_def_list_tail:
    - include: match_noise
    - match: '{{constant}}'
      scope: constant.clojure
      set: pop_list_tail
    - match: '{{symbol}}'
      scope: entity.name.function.clojure
      set: pop_list_tail
    - match: '(?=\S)'
      set: pop_list_tail
  pop_protocol_list_tail:
    - match: '\)'
      pop: true
    - match: '\('
      push: pop_declare_def_list_tail
    - include: match_expr
  pop_color_name_list_tail:
    - include: match_noise
    - match: '{{constant}}'
      scope: constant.clojure
      set: pop_list_tail
    - match: '{{symbol}}'
      scope: keyword.invoke.clojure
      set: pop_list_tail
    - match: '(?=\S)'
      set: pop_list_tail
